#Szybki start.

= Wprowadzenie =

Większość ludzi podejmujących się pisania programów dla mikrokontrolerów (czy to rodziny 51, czy AVR), niezależnie od języka jaki wybiorą do osiągnięcia swojego celu, robi to w mniej więcej taki sposób:

Cel: wciskam przycisk, dioda świeci, puszczam przycisk dioda gaśnie
Rozwiązanie:
{{{
while(1) {
    if(is_bit_clear(...)) {
        led_on();
    } else {
        led_off();
    }
}
}}}

Jeśli faktycznie tylko tyle ma robić kontroler to program jest poprawny, tylko po co do tak prostych zadań go stosować?

No właśnie, przeważnie chodzi o coś innego... Zazwyczaj nie chodzi o jeden przycisk ale o całą klawiaturę lub o wyświetlacz graficzny a nie diodę. Do tego dochodzi jeszcze cały szereg różnych styczników, silników którymi trzeba sterować. Czasami nawet w grę wchodzi komunikacja z komputerem.

Ilekroć w latach technikum, kiedy moja wiedza na temat elektroniki, przewyższała tą z programowania, wielokrotnie podejmowałem próby napisania dużych aplikacji właśnie w taki nieudolny sposób. Pisząc w asemblerze, to nawet ciężko jest pisać inaczej... Prowadzi to do sytuacji, gdzie tracimy kontrolę, nad tym co się dzieje w aplikacji, nie mamy możliwości przetestowania selektywnie części kodu, polecenia operujące na IO, są wymieszane z logiką działania, etc. 

Zastanawiałem się już wielokrotnie w jaki sposób rozwiązać, ten problem. Oto trzy ciekawe podejścia, z czego trzeci jest właśnie tym projektem:

(dodam, że zajmuje się obecnie programowaniem ATMEGA)

1. Uznałem, że warto oprogramować wszystkie peryferia mikrokontrolera, zamknąć je w klasy i w ten sposób składać aplikację jak z klocków. Faktycznie jest to pewnego rodzaju próba oddzielenia logiki od specyfiki działania kontrolera. Pomysł jednak okazał się dość żmudny i ostatecznie po programowaniu Timerów i UARTa zabrakło mi chęci do dalszej pracy. Syzyf miał lepiej. Mnogość kontrolerów i ilość różnych peryferiów okazała się zbyt duża. Do tego jeszcze niektóre peryferia takie jak porty we/wy, były tak proste, że zamknięcie ich w klasy było przerostem formy nad treścią. Do tego jeszcze doszła duża objętość powstałego kodu. Nawet aplikacja, która nic nie robi, aby użyć kilku peryferiów, musi podłączyć kod ich oprogramowania. Dramat... ale pomysł ciekawy...

2. Mój drugi pomysł, mimo bardzo długiej ścieżki myślowej :), był bardzo prosty. Mówi się że potrzeba jest matką wynalazków. Bzdura. Ja uważam, że lenistwo... Ponieważ ogólna opinia o C++ jest taka: C++ to język, w którym bohatersko pokonuje się trudności nieznane z innych języków programowania. Postanowiłem zbadać temat JAVA dla AVRów. Niestety dla mojego ubogiego ATMEGA168 (na którym obecnie się bawię) takie rozwiązanie nie wchodzi w grę. Postanowiłem więc napisać aplikację, której będzie się mówiło co ma robić za pośrednictwem połączenia szeregowego RS. Cała logika i interfejs użytkownika piszemy w JAVA, używając pewnych klas, które reprezentują polecenia mikrokontrolera. W ten sposób piszemy w JAVA a nie w C++. Całość wykonanego programu odbywa się w JAVA po stronie komutera, natomiast kontroler jest tylko ślepym wykonawcą naszej logiki. Ten pomysł jest nawet opublikowany na code.google.com pod nazwą JATMEGA. 

3. Nadszedł czas na wyciągnięcie wniosków z poprzednich lekcji... Tak powstał ten projekt. Pomysł znowu stary jak świat, jednak zastosowany w umiejętny sposób daje rewelacyjne wyniki. Ponieważ nie przepadam za C++ a w szczególności za #include, zastanawiałem się jak by to było, gdybyśmy nie musieli wszędzie pisać tego diabelskiego polecenia. Include tu, include tam, zawsze się gubię, gdzie potrzebuje jakiej referencji. Jak by na to popatrzeć z pewnej perspektywy, to ilość dyrektyw #include określa stopień powiązań jednej klasy z drugą. Oj, jeśli tego jest dużo to znaczy, że nie możemy wyciągnąć jednej fajnej klasy z projektu i dodać go do innego, bo za tym idzie zawsze cały szereg innych dodatków, od których nasz klasa jest uzależniona. Pewni ludzie już to przecież rozwiązali i nazwali to Invers of Controll (abo jakoś tak). Czyli klasy wiedzą o sobie, ale nie tworzą swoich powiązań. Robimy to z zewnątrz. To tak jakby wszystkie powiązania były wskaźnikami, a gdzieś w main() po utworzeniu tych obiektów wstrzykiwalibyśmy każdej klasie odpowiednie powiązania. To po części rozwiązuje problem wyodrębnienia klasy na zewnątrz projektu, bo powiązania można by tworzyć przez interfejsy. Coś nadal jest jednak nie tak. Możemy wyciągnąć klasę z projektu, bez jej zmieniania i dodać do innego, ale nadal za nią idą interfejsy jakich ona używa. No dobrze, skoro naszym celem jest zbudowanie klasy, która nie łączy się z żadną inną, przecież musi się jakoś komunikować z pozostałymi. Tutaj z pomocą idzie nam wzorzec zwany EventBus (lub wzorzec obserwatora). EventBus to klasa, która potrafi powiadamiać inne klasy, że wystąpiło pewne zdarzenie. Ponieważ każda klasa może takie zdarzenie wysłać, to mamy tutaj pełny asynchroniczny mechanizm komunikowania się klas między sobą, bez konieczności posiadania wiedzy o sobie. Jeśli do tego dodany jeszcze, że logikę działania zawiera jedna klasa, jednocześnie nie wiedząc nic o np. portach IO, a druga wie jak sterować portami IO, niewiedząc nic o logice - to mamy w pełni rozdzieloną aplikację na logikę i IO. Jeśli zamiast wykorzystywać LED chcemy teraz mieć 7-segmentowy wyśletlacz, to wystarczy dodać klasę potrafiącą obsługiwać taki wyświetlacz. Stosując konwencjonalne podejście wywoływania funkcji, przy takiej zmianie, potrzeba by była utworzenia nowej referencji w logica, do nowej klasy i w miejscach gdzie ta logika wywoływała poprzednią, przerobić wywołania dla nowej. W SAF logika wysyła zdarzenie konieczności wyświetlenia czegoś, zakłada ona że odbierze to zdarzenie klasa, która potrafi je obsłużyć. To jest cała esencji tego rozwiązania. Pisząc kod możemy się skoncentrować na pisaniu klas potrafiących coś robić nie wiedząc po co... oraz pisząc klasy wiedzące po co, jednak nie wiedzące jak. SAF to platforma pozwalająca się tym klasom komunikować. 